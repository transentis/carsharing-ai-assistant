import os
import json
import subprocess
import tempfile
from datetime import datetime
from typing import Dict, List, Any, Tuple

class TypstReportGenerator:
    def __init__(self):
        self.reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'reports')
        os.makedirs(self.reports_dir, exist_ok=True)
    
    def generate_report(self, title: str, data: List[Dict[str, Any]], user_question: str, context: str = "") -> Tuple[str, str]:
        """
        Generate a Typst report from knowledgegraph data and compile to PDF.
        
        Returns:
            Tuple of (typst_file_path, pdf_file_path)
        """
        # Create timestamp for unique filenames
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        base_filename = f"report_{timestamp}"
        
        # Generate Typst content
        typst_content = self._create_typst_content(title, data, user_question, context)
        
        # Write Typst file
        typst_file_path = os.path.join(self.reports_dir, f"{base_filename}.typ")
        with open(typst_file_path, 'w', encoding='utf-8') as f:
            f.write(typst_content)
        
        # Compile to PDF
        pdf_file_path = os.path.join(self.reports_dir, f"{base_filename}.pdf")
        self._compile_to_pdf(typst_file_path, pdf_file_path)
        
        return typst_file_path, pdf_file_path
    
    def _create_typst_content(self, title: str, data: List[Dict[str, Any]], user_question: str, context: str) -> str:
        """Create Typst markup content from the data."""
        
        # Start with document setup
        content = f'''#set document(title: "{title}")
#set page(numbering: "1", number-align: center)
#set text(font: "Liberation Sans", size: 11pt)

#align(center)[
  #text(size: 18pt, weight: "bold")[{title}]
  
  #v(0.5em)
  
  #text(size: 12pt)[Generated from Knowledgegraph Analysis]
  
  #v(0.5em)
  
  #text(size: 10pt)[{datetime.now().strftime("%B %d, %Y")}]
]

#v(1em)

== Executive Summary

This report presents analysis results from the enterprise knowledgegraph based on the following inquiry:

#quote[
  _{user_question}_
]

'''
        
        if context:
            content += f'''
== Context

{context}

'''
        
        content += '''
== Data Analysis

The following data was retrieved from the knowledgegraph:

'''
        
        # Add data sections
        if data:
            content += self._format_data_as_typst(data)
        else:
            content += "_No data found for the specified criteria._\n\n"
        
        # Add footer
        content += f'''
== Report Details

- *Generated:* {datetime.now().strftime("%Y-%m-%d at %H:%M:%S")}
- *Data Source:* Enterprise Knowledgegraph (Neo4j)
- *Records Analyzed:* {len(data) if data else 0}

#align(center)[
  #text(size: 8pt, fill: gray)[
    Generated by Knowledgegraph AI Assistant
  ]
]
'''
        
        return content
    
    def _format_data_as_typst(self, data: List[Dict[str, Any]]) -> str:
        """Format the data as Typst markup."""
        if not data:
            return "_No data available._\n\n"
        
        content = ""
        
        # If data contains similar records, create a table
        if len(data) > 1 and all(isinstance(item, dict) for item in data):
            # Get all unique keys across all records
            all_keys = set()
            for item in data:
                all_keys.update(item.keys())
            
            if len(all_keys) <= 5:  # Create table for manageable number of columns
                content += self._create_typst_table(data, list(all_keys))
            else:
                content += self._create_typst_list(data)
        else:
            content += self._create_typst_list(data)
        
        return content
    
    def _create_typst_table(self, data: List[Dict[str, Any]], columns: List[str]) -> str:
        """Create a Typst table from the data."""
        content = "#table(\n"
        content += f"  columns: {len(columns)},\n"
        content += "  stroke: 0.5pt,\n"
        content += "  fill: (x, y) => if y == 0 { gray.lighten(50%) },\n"
        
        # Add headers
        for col in columns:
            content += f'  [*{col.replace("_", " ").title()}*],\n'
        
        # Add data rows
        for item in data:
            for col in columns:
                value = item.get(col, "")
                # Handle different data types
                if isinstance(value, (list, dict)):
                    value = json.dumps(value, indent=2)
                content += f'  [{str(value)}],\n'
        
        content += ")\n\n"
        return content
    
    def _create_typst_list(self, data: List[Dict[str, Any]]) -> str:
        """Create a Typst list from the data."""
        content = ""
        
        for i, item in enumerate(data, 1):
            content += f"=== Record {i}\n\n"
            
            if isinstance(item, dict):
                for key, value in item.items():
                    if isinstance(value, (list, dict)):
                        value = json.dumps(value, indent=2)
                    content += f"- *{key.replace('_', ' ').title()}:* {value}\n"
            else:
                content += f"- {item}\n"
            
            content += "\n"
        
        return content
    
    def _compile_to_pdf(self, typst_file_path: str, pdf_file_path: str):
        """Compile Typst file to PDF using the Typst compiler."""
        try:
            # Try to compile with typst
            result = subprocess.run([
                'typst', 'compile', typst_file_path, pdf_file_path
            ], capture_output=True, text=True, check=True)
            
            print(f"Successfully compiled {typst_file_path} to {pdf_file_path}")
            
        except subprocess.CalledProcessError as e:
            print(f"Error compiling Typst file: {e}")
            print(f"Stderr: {e.stderr}")
            raise Exception(f"Failed to compile Typst to PDF: {e.stderr}")
        
        except FileNotFoundError:
            raise Exception("Typst compiler not found. Please install Typst: https://typst.app/docs/installation/")
    
    def cleanup_old_reports(self, max_age_hours: int = 24):
        """Remove old report files to prevent disk space buildup."""
        import time
        
        current_time = time.time()
        max_age_seconds = max_age_hours * 3600
        
        for filename in os.listdir(self.reports_dir):
            file_path = os.path.join(self.reports_dir, filename)
            if os.path.isfile(file_path):
                file_age = current_time - os.path.getmtime(file_path)
                if file_age > max_age_seconds:
                    try:
                        os.remove(file_path)
                        print(f"Removed old report file: {filename}")
                    except Exception as e:
                        print(f"Could not remove {filename}: {e}")